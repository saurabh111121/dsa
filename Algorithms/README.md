# Algorithms

This folder contains implementations and examples of fundamental algorithms organized by category.

## Structure

### Sorting
- Bubble Sort
- Selection Sort
- Insertion Sort
- Merge Sort
- Quick Sort
- Heap Sort
- Counting Sort
- Radix Sort
- Bucket Sort
- Time complexities and comparisons

### Searching
- Linear Search
- Binary Search
- Interpolation Search
- Jump Search
- Exponential Search
- Ternary Search

### DynamicProgramming
- Fibonacci series
- Knapsack problems (0/1, Unbounded, Fractional)
- Longest Common Subsequence (LCS)
- Longest Increasing Subsequence (LIS)
- Edit Distance
- Matrix Chain Multiplication
- Coin Change
- Rod Cutting
- Subset Sum
- Partition Problem
- Memoization vs Tabulation approaches

### Greedy
- Activity Selection
- Huffman Coding
- Fractional Knapsack
- Job Sequencing
- Minimum Spanning Tree (Prim's, Kruskal's)
- Dijkstra's Algorithm
- Interval Scheduling

### Backtracking
- N-Queens Problem
- Sudoku Solver
- Rat in a Maze
- Knight's Tour
- Subset Sum
- Permutations and Combinations
- Hamiltonian Path
- Graph Coloring

### Recursion
- Basic recursion concepts
- Tail recursion
- Direct vs Indirect recursion
- Tower of Hanoi
- Factorial and Fibonacci
- String permutations
- Tree and Graph recursion

### DivideAndConquer
- Merge Sort
- Quick Sort
- Binary Search
- Strassen's Matrix Multiplication
- Closest Pair of Points
- Maximum Subarray (Kadane's Algorithm)

### SlidingWindow
- Fixed size window problems
- Variable size window problems
- Maximum sum subarray
- Longest substring problems
- Minimum window substring

### TwoPointers
- Two Sum variations
- Three Sum variations
- Container with most water
- Remove duplicates
- Merge sorted arrays
- Palindrome checking

### BinarySearch
- Classic binary search
- Search in rotated array
- First and last position
- Peak element
- Search in 2D matrix
- Binary search on answer

## Algorithm Complexity Classes

- **O(1)** - Constant time
- **O(log n)** - Logarithmic time
- **O(n)** - Linear time
- **O(n log n)** - Linearithmic time
- **O(n²)** - Quadratic time
- **O(n³)** - Cubic time
- **O(2ⁿ)** - Exponential time
- **O(n!)** - Factorial time

## Learning Path

1. **Fundamentals**: Start with basic searching and sorting
2. **Recursion**: Master recursive thinking
3. **Divide and Conquer**: Learn to break problems into subproblems
4. **Dynamic Programming**: Build on recursion with memoization
5. **Greedy**: Learn optimal choice at each step
6. **Backtracking**: Explore all possibilities efficiently
7. **Advanced Patterns**: Two pointers, sliding window, binary search techniques

## Practice Strategy

For each algorithm:
1. Understand the problem it solves
2. Learn the approach and intuition
3. Implement from scratch
4. Analyze time and space complexity
5. Solve variations and related problems
6. Compare with alternative approaches